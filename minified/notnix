#!/usr/bin/lua
--[[
* notnix
Copyright (c) 2025 Kamal Fasya - Licensed under the terms of the MIT license
--]]local a={}a.info="\27[32m"a.warn="\27[33m"a.error="\27[31m"local function b(c)if c==nil then return""end;return c:gsub("%s+","")end;local function d(e)local f=""if not#e then return f end;for g=1,#e do f=f..b(e[g]).." "end;return f end;local function h(e,i)local j="M.pkgs = {\n"for g=1,#e do local k='"'..e[g]..'"'..",\n"j=j..k end;j=j.."}"local l=assert(io.open(i,"w"),a.error.."[ERROR]: error opening snapshot file")l:write("-- WARNING: do not touch this file\n".."local M = {}\n"..j.."\nreturn M")l:close()end;local function m(n)local o={}table.sort(n)for g=1,#n do if n[g]==n[g+1]then table.insert(o,n[g])end end;return o end;local function p(q,h)local r={install={},remove={}}table.sort(q)table.sort(h)if b(table.concat(q))==b(table.concat(h))then return nil end;for g=1,#q do if b(h[g])==""then table.insert(r.install,q[g])end end;for g=1,#h do if b(q[g])==""then table.insert(r.remove,h[g])end end;return r end;local function s(t)local u,v=os.rename(t,t)if v then return false end;return true end;local function w()local x=os.getenv("HOME")local y=os.getenv("XDG_CONFIG_HOME")local z=y and y.."notnix/"or x.."/.config/notnix/"if not s(z)then print(a.warn.."[WARNING]: notnix config folder not found")print(a.info.."[INFO]: creating folder "..z)os.execute("mkdir "..z)end;if not s(z..".snapshot.lua")then local l=assert(io.open(z..".snapshot.lua","w"),a.error.."[ERROR]: cant create snapshot file")l:write([[-- WARNING: do not touch this file
local M = {}
M.pkgs = {}
return M
        ]])l:close()end;if not s(z.."config.lua")then print(a.warn.."[WARNING]: config file doesn't exist")print(a.info.."[INFO]: creating config file, see "..z.." for config options")local l=assert(io.open(z.."config.lua","w"),a.error.."[ERROR]: cant create config file")l:write([[local Config = {}

-- list of all pkgs that want to be installed
-- to remove package simply remove it from this list.
-- [field-type]    : string
Config.pkgs = {
    "neovim",
}

-- change according to pkg manager & must include sudo
-- e.g "sudo apt install" for debian-based distro
-- [type]    : string
-- [default] : "sudo dnf <command>"
Config.install = "sudo dnf install"
Config.remove = "sudo dnf remove"
Config.upgrade = "sudo dnf upgrade"

-- no more Y/n confirmation before install/remove
-- [type]    : boolean
-- [default] : false
Config.assume_yes_install = false
Config.assume_yes_remove = false

return Config]])l:close()end;return z end;local function A()local z=w()local B=dofile(z.."config.lua")local C=dofile(z..".snapshot.lua")local D=B.assume_yes_install and"yes | "or""local E=B.assume_yes_remove and"yes | "or""local F=[[notnix: nix-like package-manager but not really
usage: ./notnix [option]
    options:
        -h      | --help | help -> show this help message
        upgrade | update | up   -> upgrading packages found in the list
]]if arg[1]~=nil and arg[1]=="-h"or arg[1]=="--help"or arg[1]=="help"then print(F)return end;local o=m(B.pkgs)if#o>0 then print(a.error.."[ERROR]: found duplicate:")for g=1,#o do print(a.error.."\t- "..o[g])end;print(a.error.."[ERROR]: please remove duplicates to continue")return end;if arg[1]~=nil and arg[1]=="up"or arg[1]=="update"or arg[1]=="upgrade"then print(a.info.."[INFO]: Upgrading packages")os.execute(D..B.upgrade.." "..d(B.pkgs))return end;local n=p(B.pkgs,C.pkgs)if n==nil then print(a.info.."[INFO]: Nothing to do, no packages added/removed")return end;if#n.install>0 then print(a.info.."[INFO]: Installing new packages:")for g=1,#n.install do print(a.info.."\t- "..n.install[g])end;local u,u,G=os.execute(D..B.install.." "..d(n.install))if G>0 then return end end;if#n.remove>0 then print(a.info.."[INFO]: Removing packages:")for g=1,#n.remove do print(a.info.."\t- "..n.remove[g])end;local u,u,G=os.execute(E..B.remove.." "..d(n.remove))if G>0 then return end end;h(B.pkgs,z..".snapshot.lua")end;A()
