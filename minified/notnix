#!/usr/bin/lua
--[[
* notnix
Copyright (c) 2025 Kamal Fasya - Licensed under the terms of the MIT license
--]]local a={}a.info="\27[32m"a.warn="\27[33m"a.error="\27[31m"local b={}function b.snapshot(c,d)local e="M.pkgs = {\n"for f=1,#c do local g='"'..c[f]..'"'..",\n"e=e..g end;e=e.."}"local h=assert(io.open(d,"w"),a.error.."[ERROR]: error opening snapshot file")h:write("-- WARNING: do not touch this file\n".."local M = {}\n"..e.."\nreturn M")h:close()end;function b.detect_dups(i)local j={}table.sort(i)for f=1,#i do if i[f]==i[f+1]then table.insert(j,i[f])end end;return j end;function b.detect_changes(g,k)local l={add={},remove={}}local m={}for n,o in ipairs(k)do m[o]=true end;for n,o in ipairs(g)do if not m[o]then table.insert(l.install,o)end;m[o]=nil end;for p in pairs(m)do table.insert(l.remove,p)end;return l end;local q={}function q.install(c,r,s)local t=s and"yes | "or""local n,n,u=os.execute(t..r.." "..q.load(c))return u end;function q.remove(c,v,s)local t=s and"yes | "or""local n,n,u=os.execute(t..v.." "..q.load(c))return u end;function q.load(c)local w=""if not#c then return w end;for f=1,#c do w=w..c[f]:gsub("%s+","").." "end;return w end;local x={}local function y(z)local n,A=os.rename(z,z)if A then return false end;return true end;local function B()local C=os.getenv("HOME")local D=os.getenv("XDG_CONFIG_HOME")local E=D and D.."notnix/"or C.."/.config/notnix/"if not y(E)then print(a.warn.."[WARNING]: notnix config folder not found")print(a.info.."[INFO]: creating folder "..E)os.execute("mkdir "..E)end;if not y(E..".snapshot.lua")then local h=assert(io.open(E..".snapshot.lua","w"),a.error.."[ERROR]: cant create snapshot file")h:write([[-- WARNING: do not touch this file
local M = {}
M.pkgs = {}
return M
        ]])h:close()end;if not y(E.."config.lua")then print(a.warn.."[WARNING]: config file doesn't exist")print(a.info.."[INFO]: creating config file, see "..E.." for config options")local h=assert(io.open(E.."config.lua","w"),a.error.."[ERROR]: cant create config file")h:write([[local Config = {}

-- list of all pkgs that want to be installed
-- to remove package simply remove it from this list.
-- [field-type]    : string
Config.pkgs = {
    "neovim",
}

-- change according to pkg manager & must include sudo
-- e.g "sudo apt install" for debian-based distro
-- [type]    : string
-- [default] : "sudo dnf <command>"
Config.install = "sudo dnf install"
Config.remove = "sudo dnf remove"
Config.upgrade = "sudo dnf upgrade"

-- no more Y/n confirmation before install/remove
-- [type]    : boolean
-- [default] : false
Config.assume_yes_install = false
Config.assume_yes_remove = false

return Config]])h:close()end;return E end;local function F()local E=B()local G=dofile(E.."config.lua")local H=dofile(E..".snapshot.lua")local I=G.assume_yes_install and"yes | "or""local J=G.assume_yes_remove and"yes | "or""local K=[[notnix: nix-like package-manager but not really
usage: ./notnix [option]
    options:
        -h      | --help | help -> show this help message
        upgrade | update | up   -> upgrading packages found in the list
]]if arg[1]~=nil and arg[1]=="-h"or arg[1]=="--help"or arg[1]=="help"then print(K)return end;local j=b.detect_dups(G.pkgs)if#j>0 then print(a.error.."[ERROR]: found duplicate:")for f=1,#j do print(a.error.."\t- "..j[f])end;print(a.error.."[ERROR]: please remove duplicates to continue")return end;if arg[1]~=nil and arg[1]=="up"or arg[1]=="update"or arg[1]=="upgrade"then print(a.info.."[INFO]: Upgrading packages")q.install(G.pkgs,G.install,G.assume_yes_install)return end;local i=b.detect_changes(G.pkgs,H.pkgs)if#i.add==0 and#i.remove==0 then print(a.info.."[INFO]: Nothing to do, no packages added/removed")return end;if#i.add>0 then print(a.info.."[INFO]: Installing new packages:")for f=1,#i.add do print(a.info.."\t- "..i.add[f])end;if q.install(i.add,G.install,G.assume_yes_install)>0 then return end end;if#i.remove>0 then print(a.info.."[INFO]: Removing packages:")for f=1,#i.remove do print(a.info.."\t- "..i.remove[f])end;if q.remove(i.remove,G.remove,G.assume_yes_remove)>0 then return end end;b.snapshot(G.pkgs,E..".snapshot.lua")end;F()
