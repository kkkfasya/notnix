#!/usr/bin/env lua
-- notnix
-- Copyright (c) 2025 Kamal Fasya
-- This is free a software licensed under the terms of the MIT license. See LICENSE for details.
-- TODO: test this shit
---@alias Error string | nil
---@alias PkgEntry string | { [1]: string, freeze_update?: boolean }

local CHUD = [[
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠻⠿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⡀⠀⢀⠀⠙⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⣠⣴⣶⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣷⡌⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣻⣿⣿⣿⡿⣿⣿⣿⣿⡜⣿
⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣷⢿⣿⣿⣇⣿⣿⣿⣿⣧⣿
⣿⣿⣿⣿⣿⣿⣿⡇⡆⠀⠀⣸⣿⣯⡉⠙⠛⠿⣿⣿⢺⣿⣿⡇⢿⡿⠿⠛⠉⣿
⣿⣿⣿⣿⣿⣿⣿⢁⡟⣀⣘⣛⣛⡛⢩⣤⣤⣤⣤⣀⠻⠿⠿⡇⢊⣀⣐⣚⡃⢻
⣿⣿⣿⣿⣿⣿⣿⠸⣧⣽⣿⣿⣿⡇⢼⠰⠀⠈⠙⣻⠆⣾⣷⡆⢘⡋⠉⣽⡇⢸
⣿⣿⣿⣿⣿⣿⣿⡅⣿⣿⣿⣿⣿⣧⣬⣉⣂⣚⣛⢋⣠⣿⣿⣿⢀⡐⢀⢛⡃⣸
⣿⣿⣿⣿⣿⣿⣿⣧⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⡘⣿⣿⣿⡇⣿
⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠩⡿⠛⢿⠿⢃⣿⣿⡿⢣⣿
⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⡿⣿⣿⣿⣿⣿⡿⣸⡷⠾⠿⣿⢶⡇⣿⡿⣡⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡿⢸⣿⣿⡇⣿⣿⣿⣿⣿⢣⣁⠬⣽⣿⣒⠓⣁⠿⣡⣿⣿⣿ nothing ever happens
⣿⣿⣿⣿⣿⣿⣿⠇⣿⣿⣿⣵⣿⣿⣿⣿⣿⣿⣿⣷⢖⣉⢱⣾⡟⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⢏⣾⣿⣿⢟⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⣋⣭⣾⣿⣿⣿⣿⣿
⣿⣿⡿⢟⣛⣁⣾⣿⣟⣣⣿⣿⣿⣿⣿⣿⣿⣿⣯⣯⣥⣿⣬⣝⣛⣛⣛⣛⡻⠿
⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⣝⠻⠟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿]]

local color = {}

color.info = "\27[32m"
color.warn = "\27[33m"
color.error = "\27[31m"
color.reset = function()
	print("\27[0m")
end

local SNAPSHOT_PKG = ".snapshot_pkg.lua"
local SNAPSHOT_REPO = ".snapshot_repo.lua"
local SNAPSHOT_FLATPAK = ".snapshot_flatpak.lua"
local SNAPSHOT_GIT = ".snapshot_git.lua"
local CONFIG_FILENAME = "config.lua"

---@param file string path to file
---@return boolean
local function is_file_exist(file)
	local _, err = os.rename(file, file)
	if err then
		return false
	end
	return true
end

---print error msg with coloring to stderr then os.exit(1)
---@param msg string
---@param err_color? string
local function print_error(msg, err_color)
	err_color = err_color and err_color or color.error
	io.stderr:write(err_color .. msg)
	os.exit(1)
end

-- general purpose utils for both Git and Pkg
local Util = {}

---@param a string
---@param ... string
---this is just python's os.path.join rewritten in lua lol
---Join two or more path, inserting sep '/' as needed.
---If any path after the first one is an absolute path, all previous path
---will be discarded. An empty last part will result in a path that ends with a separator.
function Util.join_path(a, ...)
	local sep = "/"
	local path = a
	local p = { ... }

	for i = 1, #p do
		local b = p[i]
		if b:sub(1, 1) == sep or not path then
			path = b
		elseif path:sub(-1) == sep then
			path = path .. b
		else
			path = path .. sep .. b
		end
	end
	return path
end

---load table of string and turn them into a single string delimited by spaces and will have trailing space
---e.g "fastfetch tmux nvim "
---@param pkgs_table PkgEntry[]
---@return string, Error err_msg
function Util.load(pkgs_table)
	if not #pkgs_table then
		return "", "packages table is empty "
	end

	local pkgs = ""

	for i = 1, #pkgs_table do
		---@type PkgEntry
		local entry = pkgs_table[i]
		if type(entry) == "string" then
			pkgs = pkgs .. entry:gsub("%s+", "") .. " "
		elseif type(entry) == "table" and type(entry[1]) == "string" then
			pkgs = pkgs .. entry[1]:gsub("%s+", "") .. " "
		end
	end
	return pkgs, nil
end

---load table of string and turn them into a single string delimited by spaces yet will have trailing space
---this one is specially used for update, since freeze_update field exist
---@param pkgs_table PkgEntry[]
---@return string, Error err_msg
function Util.load_update(pkgs_table)
	if not #pkgs_table then
		return "", "packages table is empty "
	end

	local pkgs = ""

	for i = 1, #pkgs_table do
		---@type PkgEntry
		local entry = pkgs_table[i]
		if type(entry) == "string" then
			pkgs = pkgs .. entry:gsub("%s+", "") .. " "
		elseif type(entry) == "table" and type(entry[1]) == "string" and not entry.freeze_update then
			pkgs = pkgs .. entry[1]:gsub("%s+", "") .. " "
		end
	end
	return pkgs, nil
end

---will save the pkgs_table to a given luafile
---so then it can easily be used to track the changing state of the table
---@param pkgs_table table
---@param luafile string
function Util.snapshot(pkgs_table, luafile)
	local t = "return {\n"

	for i = 1, #pkgs_table do
		local pkg = '"' .. pkgs_table[i] .. '"' .. ",\n" -- thank God lua allow trailing comma
		t = t .. pkg
	end

	t = t .. "}"
	local f = assert(io.open(luafile, "w"))
    -- stylua: ignore
    f:write(
        "-- WARNING: do not modify this file\n"
        .. t
    )
	f:close()
end

---return table of found dups
---@param pkgs table
---@return string[]
function Util.detect_dups(pkgs)
	local t_dups = {}
	table.sort(pkgs)

	for i = 1, #pkgs do
		local a = pkgs[i]:gsub("%s+", "")
		local b = pkgs[i + 1] and pkgs[i + 1]:gsub("%s+", "") or nil -- pkgs[i + 1] ? tru : fals ternary operator type shit

		if a == b then
			table.insert(t_dups, pkgs[i])
		end
	end

	return t_dups
end

---@class ChangesTable
---@field add string[] List of added packages compared to snapshot
---@field remove string[] List of removed packages compared to snapshot

--- Detects changes between a package list and a snapshot.
--- Compares a list of packages against a snapshot to identify added/removed packages
--- @param pkg string[] List of package names to compare against the snapshot
--- @param snapshot? string[] | nil list of package names representing the current state; defaults to empty table if nil
---@return ChangesTable # table with `add` and `remove` field
function Util.detect_changes(pkg, snapshot)
	if snapshot == nil then
		snapshot = {}
	end

	local changes = {
		add = {},
		remove = {},
	}

	local hashmap = {}

	-- e.g hashmap["vlc"] = true
	for _, v in ipairs(snapshot) do
		hashmap[v] = true
	end

	-- check new items in pkg and remove found ones from hashmap
	for _, v in ipairs(pkg) do
		v = v:gsub("%s+", "")
		if not hashmap[v] then
			table.insert(changes.add, v)
		end
		hashmap[v] = nil -- lua actually doesnt iterate over nil-valued key
	end

	-- remaining keys in hashmap are removed items
	for k in pairs(hashmap) do
		table.insert(changes.remove, k)
	end

	return changes
end

--- @class Pkg
--- @field install fun(pkgs_table: string[], install_cmd: string, assume_yes: boolean, custom_pkg_loader?: function): integer
--- @field remove fun(pkgs_table: string[], remove_cmd: string, assume_yes: boolean, custom_pkg_loader?: function): integer
local Pkg = {}

-- idk if docs below is necessary but whatever

---Install packages based on given list of packages using distro pkg-manager
---@param pkgs_table string[]
---@param install_cmd string
---@param assume_yes boolean
---@param custom_pkg_loader? fun(PkgEntry): string | Error err_msg # to load custom table, must adhere to (val, err) return type, i know this is such a hack and probably shouldn't exist if i actually know how to fucking code
---@return integer code return a status code, if code > 0 then it's error
function Pkg.install(pkgs_table, install_cmd, assume_yes, custom_pkg_loader)
	local pkgs, err
	if custom_pkg_loader then
		pkgs, err = custom_pkg_loader(pkgs_table)
	end
	pkgs, err = Util.load(pkgs_table)

	local yes = assume_yes and "yes | " or ""

	if err ~= nil then
		return 1
	end

	local _, _, c = os.execute(("%s %s %s"):format(yes, install_cmd, pkgs)) --[[@as integer]]
	return c
end

---Remove packages based on given list of packages using distro pkg-manager
---@param pkgs_table string[]
---@param remove_cmd string
---@param assume_yes boolean
---@param custom_pkg_loader? fun(PkgEntry): string | Error to load custom table
---@return integer code # return a status code, if code > 0 then it's error
function Pkg.remove(pkgs_table, remove_cmd, assume_yes, custom_pkg_loader)
	local pkgs, err
	if custom_pkg_loader then
		pkgs, err = custom_pkg_loader(pkgs_table)
	end
	pkgs, err = Util.load(pkgs_table)
	local yes = assume_yes and "yes | " or ""
	if err ~= nil then
		return 1
	end

	local _, _, c = os.execute(("%s %s %s"):format(yes, remove_cmd, pkgs)) --[[@as integer]]
	return c
end

---return a path to notnix config folder, does not have trailing slash
---@return string path
local function _get_config_dir_path()
	local home = os.getenv("HOME")
	local xdg_config_home = os.getenv("XDG_CONFIG_HOME")

	local path = xdg_config_home and xdg_config_home .. "notnix" or home .. "/.config/notnix"
	return path
end

---make config folder and file on $HOME/.config/ or $XDG_CONFIG_HOME if not available
local function _make_config()
	local path = _get_config_dir_path()
	local path_cfg = Util.join_path(path, CONFIG_FILENAME)
	local path_snap_pkg = Util.join_path(path, SNAPSHOT_PKG)
	local path_snap_repo = Util.join_path(path, SNAPSHOT_REPO)
	local path_snap_flatpak = Util.join_path(path, SNAPSHOT_FLATPAK)
	local cfg_str = [[--- @class Config
--- @field pkgs string[] List of packages to install; remove packages from this list to uninstall
--- @field flatpaks string[] List of Flatpak packages; WARNING: please configure Flathub repository before using this
--- @field repos string[] List of extra repositories (e.g., COPR, PPA)
--- @field install string Package manager install command (e.g., "sudo dnf install "), must include sudo
--- @field remove string Package manager remove command (e.g., "sudo dnf remove "), must include sudo
--- @field upgrade string Package manager upgrade command (e.g., "sudo dnf upgrade"), must include sudo
--- @field add_repo string Command to add repository (e.g., "sudo dnf copr enable")
--- @field remove_repo string Command to remove repository (e.g., "sudo dnf copr remove")
--- @field update_cache string Command to update package manager cache (e.g., "sudo dnf makecache")
--- @field assume_yes_install boolean If true, skips confirmation for installs; default: false
--- @field assume_yes_remove boolean If true, skips confirmation for removals; default: false
local Config = {}

Config.pkgs = {}

Config.flatpaks = {}

Config.repos = {}

Config.install = "sudo dnf install"
Config.remove = "sudo dnf remove"
Config.upgrade = "sudo dnf upgrade"

Config.add_repo = "sudo dnf copr enable"
Config.remove_repo = "sudo dnf copr remove"
Config.update_cache = "sudo dnf makecache"

Config.assume_yes_install = false
Config.assume_yes_remove = false

return Config]]

	if not is_file_exist(path) then
		print(color.warn .. "[WARNING]: notnix config folder not found")
		color.reset()
		print("[INFO]: creating folder " .. path)
		os.execute("mkdir " .. path)
	end

	if not is_file_exist(path_snap_pkg) then
		local f = assert(io.open(path_snap_pkg, "w"), color.error .. "[ERROR]: cant create snapshot file")
		print("[INFO]: creating folder " .. path)
		f:write("-- WARNING: do not modify this file\nreturn {}")
		f:close()
	end

	if not is_file_exist(path_snap_repo) then
		local f = assert(io.open(path_snap_repo, "w"), color.error .. "[ERROR]: cant create snapshot file")
		f:write("-- WARNING: do not modify this file\nreturn {}")
		f:close()
	end

	if not is_file_exist(path_snap_flatpak) then
		local f = assert(io.open(path_snap_flatpak, "w"), color.error .. "[ERROR]: cant create snapshot file")
		f:write("-- WARNING: do not modify this file\nreturn {}")
		f:close()
	end

	if not is_file_exist(path_cfg) then
		print(color.warn .. "[WARNING]: config file doesn't exist")
		color.reset()
		print("[INFO]: creating config file, see " .. path_cfg .. " for config options")
		local f = assert(io.open(path_cfg, "w"), color.error .. "[ERROR]: cant create config file")

		f:write(cfg_str)
		f:close()
	end
end

---Main notnix functionality
---this function will do os.exit when error occurs
---exit code > 0 is error
---@param cfg Config
---@param is_tracking? boolean will track installed package (default: true)
---you might not want tracking if you just want to install pkgs since this will create folder in $HOME/.config/notnix (or $XDG_CONFIG_HOME if defined)
local function notnix(cfg, is_tracking)
	local s_pkg
	local s_repo
	local s_flat

	is_tracking = is_tracking == nil and true or is_tracking

	---@type Config
	local Config
	local path = _get_config_dir_path()

	if type(cfg) == "table" then
		Config = cfg
	else
		print_error("[ERROR]: notnix() only accepts table")
	end

	if cfg == nil then
		print_error("[ERROR]: No config file is provided")
	end

	if is_tracking then
		s_pkg = dofile(Util.join_path(path, SNAPSHOT_PKG))
		s_repo = dofile(Util.join_path(path, SNAPSHOT_REPO))
		s_flat = dofile(Util.join_path(path, SNAPSHOT_FLATPAK))
	end

	-- DETECT DUPS --
	local flat_dups = Util.detect_dups(Config.flatpaks)
	if #flat_dups > 0 then
		print(color.error .. "[ERROR]: found duplicates:")
		for i = 1, #flat_dups do
			print(color.error .. "\t- " .. flat_dups[i])
		end

		print_error("[ERROR]: please remove flatpak duplicates to continue")
	end

	local repo_dups = Util.detect_dups(Config.repos)
	if #repo_dups > 0 then
		print(color.error .. "[ERROR]: found duplicates:")
		for i = 1, #repo_dups do
			print(color.error .. "\t- " .. repo_dups[i])
		end

		print_error("[ERROR]: please remove repo duplicates to continue")
	end

	local pkgs_dups = Util.detect_dups(Config.pkgs)
	if #pkgs_dups > 0 then
		print(color.error .. "[ERROR]: found duplicates:")
		for i = 1, #pkgs_dups do
			print(color.error .. "\t- " .. pkgs_dups[i])
		end

		print_error("[ERROR]: please remove duplicates to continue")
	end

	local pkgs = Util.detect_changes(Config.pkgs, s_pkg)
	local flat = Util.detect_changes(Config.flatpaks, s_flat)
	local repos = Util.detect_changes(Config.repos, s_repo)

    -- if no changes whatsoever print CHUD, because nothing happens
    -- stylua: ignore start
	if (#pkgs.add == 0 and #pkgs.remove == 0
        and #flat.add == 0 and #flat.remove == 0
        and #repos.add == 0 and #repos.remove == 0
    ) then
		print(CHUD)
		print("[INFO]: Nothing to do, no packages added/removed")
		os.exit(0)
	end
	-- stylua: ignore end

	-- == FLATPAK INSTALL & REMOVE ==
	if #flat.add > 0 then
		local y = Config.assume_yes_install and " -y" or ""
		print("[INFO]: Installing new flatpak:")
		for i = 1, #flat.add do
			print("\t- " .. flat.add[i])
			local _, _, c = os.execute("flatpak install flathub " .. flat.add[i] .. y)

			if c > 0 then
				print(color.error .. "[ERROR]: Cant install flatpak app: " .. flat.add[i])
				os.exit(1)
			end

			Util.snapshot(Config.flatpaks, Util.join_path(path, SNAPSHOT_FLATPAK))
		end
	end

	if #flat.remove > 0 then
		local y = Config.assume_yes_remove and " -y" or ""
		print("[INFO]: Removing flatpak:")
		for i = 1, #flat.remove do
			print("\t- " .. flat.remove[i])

			local _, _, c = os.execute("flatpak uninstall " .. flat.remove[i] .. y)
			if c > 0 then
				print_error("[ERROR]: Cant remove flatpak: " .. flat.remove[i])
			end
			Util.snapshot(Config.flatpaks, Util.join_path(path, SNAPSHOT_FLATPAK))
		end
	end

	-- == REPOS ADD & REMOVE ==
	if #repos.add > 0 then
		print("[INFO]: Adding new repos:")
		for i = 1, #repos.add do
			print("\t- " .. repos.add[i])
			local _, _, c = os.execute(("%s %s -y"):format(Config.add_repo, repos.add[i]))

			if c > 0 then
				print_error("[ERROR]: Cant add repo: " .. repos.add[i])
			end

			-- i can return the FILE ptr and close it after the loop finishes
			-- it's faster, but unnecessary as i am not running on apollo 11 computer
			-- BUT I'M ITCHING TO OPTIMIZE IT OH GOD I LOVE PREMATURE OPTIMIZATION
			Util.snapshot(Config.repos, Util.join_path(path, SNAPSHOT_REPO))
		end
		local _, _, c = os.execute(Config.update_cache)
		if c > 0 then
			print_error("[ERROR]: Cant update repo cache")
		end
	end

	if #repos.remove > 0 then
		print("[INFO]: Removing repos:")
		for i = 1, #repos.remove do
			print("\t- " .. repos.remove[i])
			local _, _, c = os.execute(("%s %s -y"):format(Config.remove_repo, repos.remove[i]))

			if c > 0 then
				print_error("[ERROR]: Cant remove repo: " .. repos.remove[i])
			end

			Util.snapshot(Config.repos, Util.join_path(path, SNAPSHOT_REPO))
		end
	end

	-- == PKGS INSTALL & REMOVE ==
	if #pkgs.add > 0 then
		print("[INFO]: Installing new packages:")
		for i = 1, #pkgs.add do
			print("\t- " .. pkgs.add[i])
		end

		if Pkg.install(pkgs.add, Config.install, Config.assume_yes_install) > 0 then
			os.exit(1)
		end

		Util.snapshot(Config.pkgs, Util.join_path(path, SNAPSHOT_PKG))
	end

	if #pkgs.remove > 0 then
		print("[INFO]: Removing packages:")
		for i = 1, #pkgs.remove do
			print("\t- " .. pkgs.remove[i])
		end
		if Pkg.remove(pkgs.remove, Config.remove, Config.assume_yes_remove) > 0 then
			os.exit(1)
		end
		Util.snapshot(Config.pkgs, Util.join_path(path, SNAPSHOT_PKG))
	end
end

local function main()
	local path = _get_config_dir_path()

	local help_msg = [[notnix: nix-like package-manager but not really
Usage: notnix [option]

Options:
  -h, --help                     Show this help message
  -f, --file <filename>          Install packages from a config file (untracked, keeps $XDG_CONFIG_HOME clean)
  -xi, --xarg-install <arg>      Pass an extra argument to the package manager when installing pkgs
  -xr, --xarg-remove <arg>       Pass an extra argument to the package manager when remove pkgs

  up, update, upgrade            Upgrade packages listed in the configuration
  upf, update-fp                 Update Flatpak packages from the list
  lfp, list-fp                   List all installed Flatpak applications
  lr, list-repo                  List all added repositories (e.g., COPR repos)
]]

	if arg[1] ~= nil then
		if arg[1] == "-h" or arg[1] == "--help" or arg[1] == "help" then
			print(help_msg)
			os.exit(0)
		end

		-- i dont use elseif because i think the syntax is ugly and hard to differentiate between blocks
		if arg[1] == "-f" or arg[1] == "--file" then
			local file = arg[2]
			if file == nil then
				print_error("[ERROR]: Provide a file after -f flag dude damn...")
			end

			if
				not is_file_exist(file --[[@as string]])
			then
				print_error("[ERROR]: File doesnt fucking exist")
			end

			local cfg = dofile(file)

			notnix(cfg, false)
		end

		if arg[1] == "up" or arg[1] == "update" or arg[1] == "upgrade" then
			local Config = dofile(Util.join_path(path, CONFIG_FILENAME))
			local s_pkgs = dofile(Util.join_path(path, SNAPSHOT_PKG))
			print("[INFO]: Upgrading packages")
			for i = 1, #s_pkgs do
                if (not s_pkgs[i].freeze_update) then
				    print("\t- " .. s_pkgs[i])
                end
			end
			Pkg.install(Config.pkgs, Config.upgrade, Config.assume_yes_install, Util.load_update)
			os.exit(0)
		end

		if arg[1] == "upf" or arg[1] == "update-fp" then
			local s_fp = dofile(Util.join_path(path, SNAPSHOT_FLATPAK))
			local flats = table.concat(s_fp, " ")
			local _, _, c = os.execute("flatpak update " .. flats)
			os.exit(c)
		end

		if arg[1] == "lp" or arg[1] == "list-pkg" then
			local s_pkgs = dofile(Util.join_path(path, SNAPSHOT_PKG))
			print("[INFO]: List of Installed pkgs:")
			for i = 1, #s_pkgs do
				print("\t- " .. s_pkgs[i])
			end
			os.exit(0)
		end

		if arg[1] == "lr" or arg[1] == "list-pkg" then
			local s_repos = dofile(Util.join_path(path, SNAPSHOT_REPO))
			print("[INFO]: List of repos:")
			for i = 1, #s_repos do
				print("\t- " .. s_repos[i])
			end
			os.exit(0)
		end

		if arg[1] == "-xi" or arg[1] == "--xarg-install" then
			if not arg[2] then
				print_error("[ERROR]: Provide at least one argument after -xi")
			end

			local extra_args = {}
			for i = 2, #arg do
				table.insert(extra_args, arg[i])
			end

			local x = table.concat(extra_args, " ") .. " "

			local cfg = dofile(Util.join_path(path, CONFIG_FILENAME))
			cfg.install = cfg.install .. " " .. x
			notnix(cfg)

			os.exit(0)
		end

		if arg[1] == "-xr" or arg[1] == "--xarg-remove" then
			if not arg[2] then
				print_error("[ERROR]: Provide at least one argument after -xr")
			end

			local extra_args = {}
			for i = 2, #arg do
				table.insert(extra_args, arg[i])
			end

			local x = table.concat(extra_args, " ") .. " "

			local cfg = dofile(Util.join_path(path, CONFIG_FILENAME))
			cfg.remove = cfg.remove .. " " .. x
			notnix(cfg)

			os.exit(0)
		end

		if arg[1] == "lfp" or arg[1] == "list-lfp" then
			local s_fp = dofile(Util.join_path(path, SNAPSHOT_FLATPAK))
			print("[INFO]: Installed flatpak apps:")
			for i = 1, #s_fp do
				print("\t- " .. s_fp[i])
			end

			os.exit(0)
		end

		if arg[1] == "-y" then
			local cfg = dofile(Util.join_path(path, CONFIG_FILENAME))
			cfg.assume_yes_install = true
			cfg.assume_yes_remove = true
			notnix(cfg)

			os.exit(0)
		end

		if arg[1] == "-x" then
			print_error("[ERROR]: Did you mean -xi? or -xr? notnix -h for more information")
		else
			print_error("[ERROR]: Wrong argument fool, use -h for more info")
		end
	end

	_make_config()
	local cfg = dofile(Util.join_path(path, CONFIG_FILENAME))
	notnix(cfg)
end

main()
