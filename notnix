#!/usr/bin/lua
-- notnix
-- Copyright (c) 2025 Kamal Fasya
-- This is free a software licensed under the terms of the MIT license. See LICENSE for details.

-- fuck libdnf5, wym "attributeerror: 'RepoSackWeakPtr' object has no attribute 'load_repos'"???? I follow the docs correctly motherfucker

-- TODO: make a pkgs_flatpak, it will install flatpak
-- TODO: make a pkgs_git, it will clone git repo and do installation on command provided by user
-- TODO: should i seperate Pkgs, Gits, and Utils and then bundle them into a single file with luabunlder hmmm..???


local color = {}
color.info = "\27[32m"
color.warn = "\27[33m"
color.error = "\27[31m"

-- NOTE: should i make a wrapper around common file operation?
local function is_file_exist(file)
	local _, err = os.rename(file, file)
	if err then
		return false
	end
	return true
end

-- make config file if not available, return value is path to config folder
local function _make_config()
	local home = os.getenv("HOME")
	local xdg_config_home = os.getenv("XDG_CONFIG_HOME")

	local path = xdg_config_home and xdg_config_home .. "notnix/" or home .. "/.config/notnix/"

	if not is_file_exist(path) then
		print(color.warn .. "[WARNING]: notnix config folder not found")
		print(color.info .. "[INFO]: creating folder " .. path)
		os.execute("mkdir " .. path)
	end

	-- TODO: make one for git snapshot
	if not is_file_exist(path .. ".snapshot.lua") then
		local f = assert(io.open(path .. ".snapshot.lua", "w"), color.error .. "[ERROR]: cant create snapshot file")
		f:write([[-- WARNING: do not modify this file
return {

}
        ]])
		f:close()
	end

	if not is_file_exist(path .. "config.lua") then
		print(color.warn .. "[WARNING]: config file doesn't exist")
		print(color.info .. "[INFO]: creating config file, see " .. path .. " for config options")
		local f = assert(io.open(path .. "config.lua", "w"), color.error .. "[ERROR]: cant create config file")
		f:write([[local Config = {}

-- list of all pkgs that want to be installed
-- to remove package simply remove it from this list.
-- [field-type]    : string
Config.pkgs = {
    "neovim",
}

-- change according to pkg manager & must include sudo
-- e.g "sudo apt install" for debian-based distro
-- [type]    : string
-- [default] : "sudo dnf <command>"
Config.install = "sudo dnf install"
Config.remove = "sudo dnf remove"
Config.upgrade = "sudo dnf upgrade"

-- no more Y/n confirmation before install/remove
-- [type]    : boolean
-- [default] : false
Config.assume_yes_install = false
Config.assume_yes_remove = false

return Config]])
		f:close()
	end

	return path
end

-- general purpose utils for both Gits and Pkgs
local Utils = {}

-- return table of found dups
function Utils.detect_dups(pkgs)
	local t_dups = {}
	table.sort(pkgs)

	for i = 1, #pkgs do
		if pkgs[i] == pkgs[i + 1] then
			table.insert(t_dups, pkgs[i])
		end
	end

	return t_dups
end

-- return a nested table of add and remove
function Utils.detect_changes(pkg, snapshot)
	if snapshot == nil then
		snapshot = {}
	end

	local changes = {
		add = {},
		remove = {},
	}

	local hashmap = {}

	-- e.g hashmap["vlc"] = true
	for _, v in ipairs(snapshot) do
		hashmap[v] = true
	end

	-- check new items in pkg and remove found ones from hashmap
	for _, v in ipairs(pkg) do
		if not hashmap[v] then
			table.insert(changes.add, v)
		end
		hashmap[v] = nil -- lua actually doesnt iterate over nil-valued key
	end

	-- remaining keys in hashmap are removed items
	for k in pairs(hashmap) do
		table.insert(changes.remove, k)
	end

	return changes
end

-- category specific utils
local Pkgs = {}
function Pkgs.snapshot(pkgs_table, luafile)
	local t = "return {\n"

	for i = 1, #pkgs_table do
		local pkg = '"' .. pkgs_table[i] .. '"' .. ",\n" -- thank God lua allow trailing comma
		t = t .. pkg
	end

	t = t .. "}"

	local f = assert(io.open(luafile, "w"), color.error .. "[ERROR]: error opening snapshot file")
    -- stylua: ignore
	f:write(
        "-- WARNING: do not modify this file\n"
        .. t
    )
	f:close()
end

function Pkgs.install(pkgs_table, install_cmd, assume_yes)
	local yes = assume_yes and "yes | " or ""
	local _, _, c = os.execute(yes .. install_cmd .. " " .. Pkgs.load(pkgs_table))
	return c
end

function Pkgs.remove(pkgs_table, remove_cmd, assume_yes)
	local yes = assume_yes and "yes | " or ""
	local _, _, c = os.execute(yes .. remove_cmd .. " " .. Pkgs.load(pkgs_table))
	return c
end

-- load table of pkgsb and turn them into string delimited by spaces
function Pkgs.load(pkgs_table)
	local s = ""

	if not #pkgs_table then
		return s
	end

	for i = 1, #pkgs_table do
		-- :gsub() here means remove any whitespace
		s = s .. pkgs_table[i]:gsub("%s+", "") .. " " -- yes, there will be trailing spaces and you will love it
	end

	return s
end

local Gits = {}

function Gits.snapshot(git_pkgs, luafile)
	-- WARN: different snapshot file for git tracking
	local t = "return {\n"

	for k, v in pairs(git_pkgs) do
		local repo = v["repo"]
		-- empty string for value of repo if run doesn't exist
		-- so we can differentiate between none-existent repo and none-existent run command
		local run = (not v["run"] or v["run"] ~= "") and v["run"] or "" -- (!v or v != "") ? if true : if false.. this is just ternary operator
		local pkg = ('["%s"] = [[%s]]'):format(repo, run) .. ",\n"
		t = t .. pkg
	end
	t = t .. "}"

	local f = assert(io.open(luafile, "w"), color.error .. "[ERROR]: error opening snapshot file")
    -- stylua: ignore
	f:write(
        "-- WARNING: do not modify this file\n"
        .. t
    )
	f:close()
end

--[[
1. get repo from table
2. check if repo already installed, if not then add to snapshot then install it
3. check if said repo have a run command defined


--]]

function Gits.check_remote(remote_repo)
	local _, _, c = os.execute("git ls-remote " .. remote_repo)
	return c
end

function Gits.get_repo_from_table(git_pkgs)
	local t = {}
	for k, v in pairs(git_pkgs) do
		local repo = v["repo"]
		if not repo or repo == "" then
			print(color.error .. ('[ERROR]: repo "%s" dont exist dumbass'):format(repo))
			return {}
		end
		t[repo] = v["run"]
	end
	return t
end

function Gits.install(repo, git_pkgs)
	if Gits.check_remote(v["repo"]) > 0 then
		for k, v in pairs(git_pkgs) do
			print("ERR")
			return
		end -- TODO: handle this

		if v["run"] then
			os.execute(("cd %s && %s"):format(gitclone_path, v["run"]))
		end
	end
end

-- TODO: snapshot.lua rename to snapshot_pkg.lua
local function _CLI()
	local path = _make_config()
	local Config = dofile(path .. "config.lua")
	local s_pkgs = dofile(path .. ".snapshot.lua")
	-- local s_gits = dofile(path .. ".snapshot.lua")

	local help_msg = [[notnix: nix-like package-manager but not really
usage: ./notnix [option]
    options:
        -h      | --help | help -> show this help message
        upgrade | update | up   -> upgrading packages found in the list
]]

	if arg[1] ~= nil then
		if arg[1] == "-h" or arg[1] == "--help" or arg[1] == "help" then
			print(help_msg)
			return
		elseif arg[1] == "up" or arg[1] == "update" or arg[1] == "upgrade" then
			print("[INFO]: Upgrading packages")
			for i = 1, #s_pkgs do
				print("\t- " .. s_pkgs[i])
			end
			Pkgs.install(Config.pkgs, Config.install, Config.assume_yes_install)
			Pkgs.snapshot(Config.pkgs, path .. ".snapshot.lua")
			return
		elseif arg[1] == "lp" or arg[1] == "list-pkg" then
			print("[INFO]: Installed pkgs:")
			for i = 1, #s_pkgs do
				print("\t- " .. s_pkgs[i])
			end
			return
		elseif arg[1] == "lg" or arg[1] == "list-git" then
			print("LIST GIT")
			return
		end
	end
end

-- return path of config folder
local function main()
	local path = _make_config()

	local Config = dofile(path .. "config.lua")
	local snapshot_pkg = dofile(path .. ".snapshot.lua")
	local yes_install = Config.assume_yes_install and "yes | " or ""
	local yes_remove = Config.assume_yes_remove and "yes | " or ""

	local chud = [[
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠻⠿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⡀⠀⢀⠀⠙⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⣠⣴⣶⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣷⡌⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣻⣿⣿⣿⡿⣿⣿⣿⣿⡜⣿
⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣷⢿⣿⣿⣇⣿⣿⣿⣿⣧⣿
⣿⣿⣿⣿⣿⣿⣿⡇⡆⠀⠀⣸⣿⣯⡉⠙⠛⠿⣿⣿⢺⣿⣿⡇⢿⡿⠿⠛⠉⣿
⣿⣿⣿⣿⣿⣿⣿⢁⡟⣀⣘⣛⣛⡛⢩⣤⣤⣤⣤⣀⠻⠿⠿⡇⢊⣀⣐⣚⡃⢻
⣿⣿⣿⣿⣿⣿⣿⠸⣧⣽⣿⣿⣿⡇⢼⠰⠀⠈⠙⣻⠆⣾⣷⡆⢘⡋⠉⣽⡇⢸
⣿⣿⣿⣿⣿⣿⣿⡅⣿⣿⣿⣿⣿⣧⣬⣉⣂⣚⣛⢋⣠⣿⣿⣿⢀⡐⢀⢛⡃⣸
⣿⣿⣿⣿⣿⣿⣿⣧⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⡘⣿⣿⣿⡇⣿
⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠩⡿⠛⢿⠿⢃⣿⣿⡿⢣⣿
⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⡿⣿⣿⣿⣿⣿⡿⣸⡷⠾⠿⣿⢶⡇⣿⡿⣡⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡿⢸⣿⣿⡇⣿⣿⣿⣿⣿⢣⣁⠬⣽⣿⣒⠓⣁⠿⣡⣿⣿⣿ nothing ever happens
⣿⣿⣿⣿⣿⣿⣿⠇⣿⣿⣿⣵⣿⣿⣿⣿⣿⣿⣿⣷⢖⣉⢱⣾⡟⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⢏⣾⣿⣿⢟⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⣋⣭⣾⣿⣿⣿⣿⣿
⣿⣿⡿⢟⣛⣁⣾⣿⣟⣣⣿⣿⣿⣿⣿⣿⣿⣿⣯⣯⣥⣿⣬⣝⣛⣛⣛⣛⡻⠿
⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⣝⠻⠟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿]]

	local t_dups = Utils.detect_dups(Config.pkgs)
	if #t_dups > 0 then
		print(color.error .. "[ERROR]: found duplicate:")
		for i = 1, #t_dups do
			print(color.error .. "\t- " .. t_dups[i])
		end

		print(color.error .. "[ERROR]: please remove duplicates to continue")
		return
	end

	local pkgs = Utils.detect_changes(Config.pkgs, snapshot_pkg)
	if #pkgs.add == 0 and #pkgs.remove == 0 then
		print(chud)
		print(color.info .. "[INFO]: Nothing to do, no packages added/removed")
		return
	end

	if #pkgs.add > 0 then
		print(color.info .. "[INFO]: Installing new packages:")
		for i = 1, #pkgs.add do
			print(color.info .. "\t- " .. pkgs.add[i])
		end

		if Pkgs.install(pkgs.add, Config.install, Config.assume_yes_install) > 0 then
			return
		end
	end

	if #pkgs.remove > 0 then
		print(color.info .. "[INFO]: Removing packages:")
		for i = 1, #pkgs.remove do
			print(color.info .. "\t- " .. pkgs.remove[i])
		end
		if Pkgs.remove(pkgs.remove, Config.remove, Config.assume_yes_remove) > 0 then
			return
		end
	end

	Pkgs.snapshot(Config.pkgs, path .. ".snapshot.lua")
end
_CLI()
